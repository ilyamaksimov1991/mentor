package money

import (
	"encoding/xml"
	"fmt"
	"golang.org/x/net/html/charset"
	"net/http"
)

const (
	moneyEndpoint = "http://www.cbr.ru/scripts/XML_daily.asp"
)

var money = map[string]bool{"R01235": true, "R01239": true}

type AutoGenerated struct {
	ValCurs struct {
		Valute []struct {
			NumCode  string `xml:"NumCode"`
			CharCode string `xml:"CharCode"`
			Nominal  string `xml:"Nominal"`
			Name     string `xml:"Name"`
			Value    string `xml:"Value"`
			ID       string `xml:"_ID"`
		} `xml:"Valute"`
		Date string `xml:"_Date"`
		Name string `xml:"_name"`
	} `xml:"ValCurs"`
}

type ValCurs struct {
	XMLName xml.Name `xml:"ValCurs"`
	Text    string   `xml:",chardata"`
	Date    string   `xml:"Date,attr"`
	Name    string   `xml:"name,attr"`
	Valute  []struct {
		Text     string `xml:",chardata"`
		ID       string `xml:"ID,attr"`
		NumCode  string `xml:"NumCode"`
		CharCode string `xml:"CharCode"`
		Nominal  string `xml:"Nominal"`
		Name     string `xml:"Name"`
		Value    string `xml:"Value"`
	} `xml:"Valute"`
}

type Money struct {
}

func NewMoney() *Money {
	return &Money{}
}

func (m *Money) Get() (string, error) {
	req, err := http.NewRequest("GET", moneyEndpoint, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create money request: %w", err)
	}

	q := req.URL.Query()
	req.URL.RawQuery = q.Encode()

	resp, err := http.Get(req.URL.String())
	if err != nil {
		return "", fmt.Errorf("failed to complete the money request: %w", err)
	}
	defer resp.Body.Close()
	curs := &ValCurs{}
	derr := xml.NewDecoder(resp.Body)
	derr.CharsetReader = charset.NewReaderLabel
	err = derr.Decode(curs)
	if err != nil {
		return "", fmt.Errorf("curs decoding error: %w", err)
	}

	str := ""
	for _, val := range curs.Valute {
		if _, ok := money[val.ID]; ok {
			str += fmt.Sprintf(" %v %v\n", val.CharCode, val.Value)
		}
	}

	return str, nil
}
